# Cascoda A4I Round

This project was part of A4I Round 6 funding and was conducted in collaboration with [Cascoda](https://www.cascoda.com/). The project investigates how node receive sensitivity affects the Hidden Node Problem (HNP) and the network performance.

## Prerequisites

* Python 3.9

* [Poetry](https://python-poetry.org/docs/master/#installing-with-the-official-installer)

* [Wireshark](https://www.wireshark.org/download.html) & TShark (included with WireShark)

* [Whitefield repository](https://github.com/Cascoda/whitefield/tree/ot-integration) (`ot-integration` branch)

## Installation

Ensure the ot-wf-results-gen and whitefield repositories are structured at the same directory level in relation to each other.

```text
.
├── ot-wf-results-gen
└── whitefield
```

### Install dependencies in a virtual environment

In the root directory of the ot-wf-results-gen repository. Ensure the `pyproject.toml` file exists.
1. Run `poetry install` to create a venv virtual environment and install this package and its dependencies there (add `--no-dev` flag to exclude dev dependencies)
2. Ensure the python version being used in virtual env is correct with `poetry env info`

### Whitefield Setup

To setup whitefield (after cloning and storing in the correct directory structure in relation to this ot-wf-results-gen repo) follow the [build instructions](https://github.com/Cascoda/whitefield/tree/ot-integration#setup-instructions).

### Register end node addresses to produce correct simulation runs via whitefield

To produce correct simulation results and to be able to analyse the simulations in WireShark / TShark / this ot-wf-results-gen repo. Whitefield needs to register end node addresses for each node in the simulation.

Before running all of the simulations using this tool it is advised to run a single simulation in the whitefield repo with `./invoke_whitefield config/wf_ot.cfg`, and ensure all of the nodes have had an extended address generated for them.

Check for extended node address:
1. Search for `ext_addr` in `log/airline.log`
2. Each node in the network should give a message with the following format:

    ```text
    Setting node 1 ext_addr: 0xffffffffffffffff -> 0x66e80055237c0326
    ```

    *Example `airline.log` with registered extended node addresses*

    ```text
    Setting node 2 ext_addr: 0xffffffffffffffff -> 0x1e55391040093aed
    ScheduleCommlineRx() OTmsgrecvCallback

    Setting node 1 ext_addr: 0xffffffffffffffff -> 0xba7f126015f2b05b
    ScheduleCommlineRx() OTmsgrecvCallback
    In OTmsgrecvCallback, sim time: 0, aliveNodes: 3
    INFO  00:00:00.002 [OTmsgrecvCallback:365] OT_EVENT_TYPE_STATUS_PUSH RECEIVED...
    INFO  00:00:00.002 [OTProcessStatusPush:291] In OTProcessStatusPush
    extaddr=26c96fde453afa92
    Extracted extaddr
    Setting node 3 ext_addr: 0xffffffffffffffff -> 0x26c96fde453afa92
    ```

3. If this message does not appear for every node in the network, manually edit `config/wf_ot.cfg` with the following changes:

    ```text
    simulationEndTime=5
    rxSensitivity[X]=-105 # Make this change for all nodes
    nodeExec[X]=thirdparty/openthread/build/simulation/examples/apps/cli/ot-cli-ftd $NODEID+1 UDSPATH=log OT-PCAP=pcap # Make this change for all nodes
    ```

    A modified version of the config file with all of the required changes has been included in the config folder as `./config/wf_out_v1_8_register_whitefield.cfg`.

4. Run `./invoke_whitefield config/wf_ot.cfg` and keep checking that each node has a registered extended address.

Once all the extended addresses have been generated, verify that the simulation executed as expected by looking at the pcap file in WireShark. You should see MLE messages, ACKs, and ICMPv6 messages.

### Adding the decryption key to WireShark and TShark

The pcap files generated by Whitefield are encrypted. The automated workflow (specifically the stats and PDF generation) in this repo require the pcap files to be decrypted. The automated workflow utilises TShark, the command line version of WireShark. However, the decryption key needs to be add in via the WireShark UI.

See [this guide](https://github.com/Cascoda/whitefield/blob/ot-integration/docs/OpenThread.md) on the whitefield repo for information on how to decrypt (and additional information about OpenThread). Below is an extract for adding the decryption key to WireShark.

```markdown
Gathering Logs/Data/Statistics:

Once the simulation has executed, logs can be obtained from log/airline.log, and pcap files for each node from pcap/pkt-0-0.pcap (for node 0, for example). The pcap files can be opened in WireShark.

Once opened in WireShark, do the following in order to allow WireShark to correctly interpret and decode the pcap file:

    Add the network key as a decription key.
        * Open the config/wf_ot.cfg file.
        * Locate the nodeConfig parameter. This is a semicolon-separated list of key-value pairs.
        * One of the 'keys' is networkkey. Copy the corresponding value, e.g. 00112233445566778899aabbccddeeff.
        * Go back to WireShark, and click on Edit > Preferences. This will open up the Preferences window.
        * In the options of the left, expand the Protocols list, and scroll down until you find IEEE 802.15.4.
        * Select IEEE 802.15.4, and click on Edit... next to "Decryption Keys". This will open up a window where you can add/remove/edit decryption keys.
        * On the lower left corner of the window, there is a '+' symbol. Click on this symbol.
        * Paste the network key that you had copied from the config file.
        * Under 'Key hash', select 'Thread hash'.
        * Now click 'OK' in the bottom right corner of the window.
        * Click 'OK' again to exit out of the Preferences window.
```

## Usage

The repository contains 4 main utilities:
* [Configuration file editor](#config-editor)
* [Automated Whitefield-Openthread workflow with integrated Hidden Node Problem detector](#automated-workflow)
* [Stats generation from Whitefield-Openthread simulation outputs](#stats-generation)
* [PDF report generator](#pdf-generation)

To run the end-to-end workflow use:

```bash
cd cascoda
make run_all csv=<PATH-TO-CSV>
```

### Config Editor

The configuration editor is built utilising bash shell scripting and sed. It takes an input configuration file from the Cascoda Whitefield-Openthread integration v1.8, an example of the input configuration file can be found in `config/wf_ot_v1_8.cfg`.

For full instructions run:

```bash
cd cascoda
./config-editor.sh -h
```

### Automated Workflow

The automated workflow uses `config-editor.sh` to generate configuration files as required. It runs the Whitefield-Openthread simulation for each receive sensitivity between -99 and -105. gradually increasing the node distance until the HNP is detected for each sensitivity.

Each simulation is run on a 3 node network for 1 minute virtual simulation time with starting node positions:

```bash
nodePosition[0]=0,0,0
nodePosition[1]=0,5,0
nodePosition[2]=0,10,0
```

The HNP is detected by searching for `snr <= snr_min, dropped` in the `airline.log` generated by the Whitefield-Openthread simulation.

Workflow logs can be found in `log/`. Generated configuration files can be found in `config/`. Simulation logs and pcap files can be found in `simulation_outputs/`.

To run just the automated workflow use:

```bash
cd cascoda
make run_hdn
```

OR

```bash
cd cascoda
poetry run python hdn_detector.py
```

### Stats Generation

Before continuing with stats generation, ensure you have added a decryption key to WireShark. For more information please see "[Adding the decryption key to WireShark and TShark](#adding-the-decryption-key-to-wireshark-and-tshark)"

#### List of stats generated

For further details on how these stats were generated. View the `get_stats(pcap_directory, config_file_path)` method defined in `./cascoda/extract_stats.py`

* `replies_from_central_node`
    * total number of replies sent to node 0 and 2.

* `max_theoretical`
    * max theoretical replies (if network had no collisions)

* `replies_to_0`
    * from `replies_from_central_node` extract only those sent to node 0

* `replies_to_2`
    * from `replies_from_central_node` extract only those sent to node 2

* `packets_sent_0`
    * the number of packets sent by node 0

* `packets_sent_2`
    * the number of packets sent by node 2

* `total_packets_sent`
    * number of packets to node 0 and 2 (== `replies_from_central_node`?)

* `unique_packets_sent_0`
    * the number of unique packet sequences in the pcap file for node 0
    * (the highest sequence number)

* `unique_packets_sent_2`
    * the number of unique packet sequences in the pcap file for node 2
    * (the highest sequence number)

* `total_unique_packets_sent`
    * the sum of `unique_packets_sent_0` and `unique_packets_sent_2`

* `retries_per_unique_sequence_node_0`
    * a frequency of the number of retries per sequence number for node 0
    * (count the number of times each sequence number appears in the pcap)

* `retries_per_unique_sequence_node_2`
    * a frequency of the number of retries per sequence number for node 2
    * (count the number of times each sequence number appears in the pcap)

* `sequence_numbers_0`
    * the sequence number column from the pcap file for node 0

* `sequence_numbers_2`
    * the sequence number column from the pcap file for node 2

* `time_0`
    * the time column from the pcap file for node 0

* `time_2`
    * the time column from the pcap file for node 2

* `%_responded`
    * total replies / total sent (to central node), as a percentage (to 2 decimal places)
    * (`replies_from_central_node` / `total_packets_sent`) * 100

* `network_efficiency_%`
    * total replies / max theoretical replies, as a percentage (to 2 decimal places)
    * (`replies_from_central_node` / `max_theoretical`) * 100

* `Node_0_request_stat`
    * A sentence in the form "X requests were sent, Y were unique".
    * Using `packets_sent_0` and `unique_packets_sent_0`

* `Node_2_request_stat`
    * A sentence in the form "X requests were sent, Y were unique"
    * Using `packets_sent_0` and `unique_packets_sent_0`

* `n`,`t`,`s`,`x`,`p`
    * These are extracted from the programmatically generated file paths
    * `n` = number of nodes in the network
    * `t` = virtual simulation time
    * `s` = receive sensitivity
    * `x` = node position iteration. `x * 5` is the node Y position distance, e.g. when `x=6`, a 3 node network will have the positions: `[0,0,0], [0,30,0], [0,60,0]`.
    * `p` = ping size

To run just stats generation use:

```bash
cd cascoda
make run_stats csv=<PATH-TO-CSV>
```

OR

```bash
cd cascoda
poetry run python extract_stats.py <PATH-TO-CSV>
```

If no `<PATH-TO-CSV>` is provided for the commands above, the default output is:
`./cascoda/hidden_node_simulation_export.csv`

### PDF Generation

A subsection of the generated stats are summarized in a PDF. The PDF report displays the following:
* Node position where the HNP was detected for each receive sensitivity
* The simulation parameters
* The percentage of requests responded to
* The network efficiency (central node replies / max theoretical requests)
* Node 0 requests sent stats
* Node 2 requests sent stats

To run just PDF generation use:

```bash
cd cascoda
make run_report csv=<PATH-TO-CSV>
```

OR

```bash
cd cascoda
poetry run python generate_report.py <PATH-TO-CSV>
```

If no `<PATH-TO-CSV>` is provided for the commands above, the default output is:
`./cascoda/hidden_node_simulation_export.csv`

To change the header with the logos on the first page, replace the file `cascoda/assets/A4_background.png` with your desired background.

## Authors

* **Humzah Javid**, STFC Hartree Centre
* **Tim Powell**, STFC Hartree Centre

## License

This project is licensed under the MIT Licence - see the [LICENCE](LICENCE) file for details.
